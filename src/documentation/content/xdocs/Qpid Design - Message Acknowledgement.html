<html>
    <head>
        <title>Apache Qpid : Qpid Design - Message Acknowledgement</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            Apache Qpid : Qpid Design - Message Acknowledgement
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Dec 01, 2006 by <font color="#0050B2">mmccorma</font>.
				    </div>

				    <p><b>This page is under review for accuracy</b></p>

<h3><a name="QpidDesign-MessageAcknowledgement-MessageAcknowledgementsandDeliveryModes"></a>Message Acknowledgements and Delivery Modes</h3>

<p>When implementing the JMS client it became apparent that the JMS specification offered a considerable degree of latitude for interpreting the precise semantics of acknowledgement modes and it also did not cover all acknowledgement modes that are of interest.</p>

<p>Here we describe the precise semantics of the JMS acknowledgement modes and the additional modes that the JMS client provides.</p>

<p>In this discussion, "the client" refers to the JMS client implementation and "the user" refers to code that is part of the client application (i.e. code written by the end-user developer).</p>

<h4><a name="QpidDesign-MessageAcknowledgement-AUTOACKNOWLEDGE%28JMS%29"></a>AUTO_ACKNOWLEDGE (JMS)</h4>

<p>In this mode, the client acknowledges each message once it has been received by the user. In the case of an asynchronous message consumer, this means that an acknowledgement is sent once the onMessage method of a message listener has completed without throwing an exception of any sort. For a synchronous consumer, it means when the receive() method has returned the message to the user.</p>

<p>In this mode, each HANDLE NOTIFY sent from the server to the client will result in one CHANNEL ACK being sent from the client to the server.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-CLIENTACKNOWLEDGE%28JMS%29"></a>CLIENT_ACKNOWLEDGE (JMS)</h4>

<p>In this mode, the user acknowledges messages manually by calling the acknowledge() method. The user does not have to acknowledge each message therefore the user can decide on a batching strategy in order to reduce network traffic.</p>

<p>The JMS does not say how many message a client is allowed to receive before acknowledging. However, it does talk in vague terms about implementations making sure clients don't go too long without acknowledging to avoid resource exhaustion.</p>

<p>Qpid introduces a "prefetch" which specifies, for a particular destination, how many messages the client can read without sending an acknowldgement. The method Session.setDefaultPrefetch(int) allows a default value to be configured at the session level and an overloaded createConsumer() method exists allowing it to be specified at the point of consumer construction.</p>

<p>Calling Message.acknowledge() sends a CHANNEL ACK to be sent from the client to the server. This acknowledges the receipt of all messages up to and including this one.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-DUPSOKACKNOWLEDGE%28JMS%29"></a>DUPS_OK_ACKNOWLEDGE (JMS)</h4>

<p>In this mode, the client acknowledges message receipt as in the case of AUTO_ACKNOWLEDGE but is not obliged to acknowledge each message immediately upon successful completion of the onMessage() or receive() methods.</p>

<p>This means that the client can have an "acknowledgement strategy" that can provide higher performance at the expense of potential redelivery of messages in the event of a failure.</p>

<p>Qpid provides a default configurable strategy parameterised on number of messages received and elapsed time since last acknowledgement. The user can configure the client to send acknowledgements every n messages (where n &lt;= the prefetch value for the consumer) or every k milliseconds whichever is reached sooner. Values of zero for either n or k means that component of the trigger is disabled. Setting n = 0 and k = 0 results in behaviour identical to CLIENT_ACKNOWLEDGE. Setting n = 1 and k = 0 results in behaviour identical to AUTO_ACKNOWLEDGE.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-PREACKNOWLEDGE%28nonJMS%29"></a>PRE_ACKNOWLEDGE (non-JMS)</h4>

<p>A mode not covered by the JMS specification is one where the client acknowledges a message before calling the onMessage() or receive() methods. This method results in the server receiving one CHANNEL ACK per HANDLE NOTIFY as in AUTO_ACKNOWLEDGE but the difference is that the ack will/can(? - this choice could cause a 'DUP' effect) be sent even if user code can throws an error.</p>

<p>This is useful where the user does not want to trigger redelivery of a message if user code fails or where synchronous operation is used and it is expected that there is some delay before receive() is called (which would in turn cause the server to have to wait some time before receiving the ack).</p>

<p>The constant Session.PRE_ACKNOWLEDGE defines this mode.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-NOACKNOWLEDGE%28nonJMS%29"></a>NO_ACKNOWLEDGE (non-JMS)</h4>

<p>Certain data may be time sensitive in the sense that redelivery is pointless - if the client cannot process it at the instant it is sent there is no point in redelivering it.</p>

<p>In this case, acks are redundant. Since TCP means that the server can be sure the client received the message the only problem could be client error.</p>

<p>Setting NO_ACKNOWLEDGE means that the client never needs to send CHANNEL_ACK messages. The constant Session.NO_ACKNOWLEDGE defines this mode.</p>

<h3><a name="QpidDesign-MessageAcknowledgement-DeliveryModes"></a>Delivery Modes</h3>

<p>For message production, similar considerations apply. JMS defines two delivery modes, PERSISTENT and NON_PERSISTENT which allow the implmentor considerable freedom of implementation.</p>

<p>Unfortunately the JMS specification addresses what are really two separate reliability concerns with a single delivery mode. OpenAMQ adds an additional mode to give the user the ability to have finer control over the tradeoff between performance and reliability.</p>

<p>The default delivery mode can be set on a producer. This can be overridden on each message sent.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-PERSISTENT%28JMS%29"></a>PERSISTENT (JMS)</h4>

<p>Persistent is the straightforward option. Messages are sent with the persistent flag set to true which means that they will be committed to stable storage. HANDLE SEND frames are sent with the confirm tag set to true. When the client receives the HANDLE REPLY frame it knows that the message has been committed to stable storage on the broker.</p>

<p><b>We need to clarify with Pieter what confirm tags really mean. Do they mean pure physical receipt of the message or receipt &amp; completion of all necessary processing? The semantics of 'processing' will vary from message-type to message-type. For example would 'HANDLE SEND' mean delivery to all end points (clients)... unlikely... or delivery to all the data-structures - queues, topics etc, or just delivery to the mux?</b></p>

<p><b>In this particular case 'processing' would probably mean writing to some persistent storage. Whatever the 'rule', it should be unambiguous, understood by all developers and enforced. Perhaps a 'processed' flag could be associated with the tag to indicate that it should only be generated when processing has also completed? Alternatively this could be a field that can optionally piggy-back in the confirm tag indicating that the confirm tag is also acknowledgement of completion of all necessary processing. If it does not contain that flag, then a separate acknowledgement message may be generated some time later. This gives the broker some implementation freedom.</b></p>

<p>The MessageProducer.send() method blocks until the HANDLE REPLY has been received therefore the user can know that a message has been reliably sent to the broker.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-NONPERSISTENT%28JMS%29"></a>NON_PERSISTENT (JMS)</h4>

<p>Non persistent gives maximum performance with least guarantees. The persistent flag is set to false in each message which means that if the broker dies all messages that have no been delivered at that point are lost irretrievably.</p>

<p>Also no acks are requested in the HANDLE SEND. Acks are pointless in this case since after sending the ack the server could die and the message would be lost.</p>

<h4><a name="QpidDesign-MessageAcknowledgement-PERSISTENTGROUPACK%28nonJMS%29"></a>PERSISTENT_GROUPACK (non-JMS)</h4>

<p>An ack means that the client knows that the last message it sent was received successfully. However, acks have a considerable performance overhead. A client may want to be able to send message quickly but also have the guarantee that if the broker dies the messages will not be lost.</p>

<p>PERSISTENT_GROUPACK means that messages are written to stable storage, which incurs an overhead, but the client only requests an ack every n messages. The Session.setGroupAckThreshold() method allows the client to specify the ack frequency.</p>

<p>Note that this is different to a transacted commit since in this mode, messages can be delivered to client before the group-ack. Transacted messages are not available to clients until the commit.</p>

<p>TODO: define some API to allow the client to determine the set of mesages not acked in the event of failure.</p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="border/border_bottom.gif"><img src="border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Apr 22, 2008 02:47</font></td>
		    </tr>
	    </table>
    </body>
</html>