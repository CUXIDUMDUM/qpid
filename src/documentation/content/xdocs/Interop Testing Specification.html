<html>
    <head>
        <title>Apache Qpid : Interop Testing Specification</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            Apache Qpid : Interop Testing Specification
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Nov 22, 2007 by <font color="#0050B2">rupertlssmith</font>.
				    </div>

				    <h1><a name="InteropTestingSpecification-QpidInteropTestingSpec.WorkingCopy."></a>Qpid Interop Testing Spec. Working Copy.</h1>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Draft. </th>
<td class='confluenceTd'> Rupert Smith. </td>
<td class='confluenceTd'> 22nd Feb 2007 </td>
<td class='confluenceTd'> Document started. </td>
</tr>
<tr>
<th class='confluenceTh'> Working Copy. </th>
<td class='confluenceTd'> Rupert Smith. </td>
<td class='confluenceTd'> 6th Mar 2007 </td>
<td class='confluenceTd'> Document updated from feedback to draft on qpid-dev list. Last requirement # used: 47 </td>
</tr>
<tr>
<th class='confluenceTh'> Working Copy. </th>
<td class='confluenceTd'> Rupert Smith. </td>
<td class='confluenceTd'> 7th Mar 2007 </td>
<td class='confluenceTd'> Senders and receivers to send reports to coordinator. Reply-to added to broadcast messages. Last requirement # used: 49 </td>
</tr>
<tr>
<th class='confluenceTh'> Working Copy. </th>
<td class='confluenceTd'> Rupert Smith. </td>
<td class='confluenceTd'> 13th Mar 2007 </td>
<td class='confluenceTd'> Added test case names. Last requirement # used: 52 </td>
</tr>
<tr>
<th class='confluenceTh'> Working Copy. </th>
<td class='confluenceTd'> Rupert Smith. </td>
<td class='confluenceTd'> 25th Sept 2007 </td>
<td class='confluenceTd'> Added test cases for message size variation. Last requirement # used: 60 </td>
</tr>
<tr>
<th class='confluenceTh'> Version 2 Work in Progress. </th>
<td class='confluenceTd'> Rupert Smith </td>
<td class='confluenceTd'> 22nd Nov 2007 </td>
<td class='confluenceTd'> Test framework being expanded to cover functional and perforance tests and a much wider variety of testing possibilities. </td>
</tr>
</tbody></table>

<h2><a name="InteropTestingSpecification-Introduction%3A"></a>Introduction:</h2>

<p> The requirements in this specification use a common format, an example of which is given below:</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> RE-1. </th>
<th class='confluenceTh'> Sample Requirement. </th>
<td class='confluenceTd'> A brief descritpion of the requirement. </td>
</tr>
</tbody></table>

<p> The requirements are numbered from 1.</p>

<h2><a name="InteropTestingSpecification-Purpose%3A"></a>Purpose:</h2>

<ul>
	<li>Test sending from and receiving by each of the clients in Qpid over both of the broker implementations.</li>
</ul>


<ul>
	<li>Enable testing of any JMS compliant product, by keeping a pure JMS sub-set of the testing framework seperate. This only applies to Java messaging client implementations.</li>
</ul>


<ul>
	<li>Provide a parameter driven test framework, that can be used to generate many testing scenarios for different messaging modes.</li>
</ul>


<ul>
	<li>Allow functional testing of messaging at the product surface, through the standard interfaces/protocols (JMS, AMQP), so that the same test suite may be applied over different implementations.</li>
</ul>


<ul>
	<li>Allow tests to be posed in terms of abstract asynchronous messaging concepts that AMQP and JMS support, rather than at the level of direct interfaces. This allows the same tests to carry forward as standards and products evolve.</li>
</ul>


<ul>
	<li>Enable interopability testing between any AMQP compliant components, not just those in Qpid.</li>
</ul>


<ul>
	<li>Allow performance testing to be carried out accross a distributed set of edge nodes connected to a messaging broker.</li>
</ul>


<ul>
	<li>Make tests robust enough to run as part of an automated build. The scripts should pass or fail, not hang, wait forever, run out of memory or otherwise cause an automated build process to fail to complete.</li>
</ul>


<ul>
	<li>Be capable of running the full test suite on several machines in a hands free way. In particular C++ tests need to run on unix and .Net on windows, necessitating a multi-box solution for full interop testing.</li>
</ul>


<ul>
	<li>Be capable of running the same test cases accross message topologies ranging from a single test node running in the same process as a broker, to many test nodes running on different machines, remotely connected to a broker.</li>
</ul>


<h2><a name="InteropTestingSpecification-Constraints%3A"></a>Constraints:</h2>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-1. </th>
<th class='confluenceTh'> Operating System. </th>
<td class='confluenceTd'> The test client scripts must run on Unix and Windows. If a test client implementation is only available on one of these platforms it only needs to run on its supported platform. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-2. </th>
<th class='confluenceTh'> Scripting Language. </th>
<td class='confluenceTd'> Each test client must be startable from a Unix shell script. Tests run on Windows will use Cygwin to run these scripts. There is no need to support Windows .bat scripts. </td>
</tr>
</tbody></table>

<h2><a name="InteropTestingSpecification-FunctionalRequirements%3A"></a>Functional Requirements:</h2>

<h3><a name="InteropTestingSpecification-Introduction."></a>Introduction.</h3>

<p> These requirements describe the behaviour of test clients for testing between different client implementations of AMQP. Each client is expected to be a single program that is capable of sending test messages to other clients and receiving and responding to test messages received from other test clients. The clients are not to be run as seperate programs for the sending and receiving parts for the sake of convenience in being able to run the clients as part of an automated build. The clients will listen for control messages broadcast by a master coordinator, to enlist them in tests, tell them which test to run, when to begin their tests, where to submit reports about the tests and when to shut down. </p>

<p> A centralized approach has been chosen, using a single coordinator, as test framework code which would otherwise have to be duplicated amongst all the clients will generally be put in the coordinator. The idea is to place as much logic as possible in the coordinator and as little as possible in the clients which means that code will only have to be written and maintained in one place. This code will include code for enlisting clients for tests, deciding which test case to run, and formatting and logging out the results. The alternative would be to have a de-centralized approach, where each client broadcasts the test enlist messages, finds out what other clients are available to talk to, choses which tests to run and outputs the test results. One advantage of the centralized approach, is that the coordinator should know which clients are available, and therefore which clients cannot run particular tests, or fail completely to run particular tests, and should therefore be able to log out failures for clients that fail tests in a more reliable way, than if it were up to the clients to log their own failures and ommissions.</p>

<h2><a name="InteropTestingSpecification-Buildtestsoutofastandardizedconstructionblock."></a>Build tests out of a standardized construction block.</h2>

<ul>
	<li>Diagram: The test circuit.</li>
</ul>


<p>Publisher/Receiver pair.<br/>
Each end of which is a Producer/Consumer unit.<br/>
 M producers, N consumers, talking over Z destinations.</p>

<p> One of the stated aima of this specificiation is to "Allow tests to be posed in terms of abstract asynchronous messaging concepts that AMQP and JMS support, rather than at the level of direct interfaces". For example, we know that messages sent in a transaction, must not be delivered until the transaction is committed. This is true of AMQP as it is of JMS; as AMQP is intended to provide similar messaging semantics to JMS. The statement is also true, whether the messages are broadcast to many receivers or sent to just one.</p>

<p> The standard consruction block for a test, is a test circuit. This consists of a publisher, and a receiver. The publisher and receiver may reside on the same machine, or may be distributed. Will use a standard set of properties to define the desired circuit topology.</p>

<p> Tests are always to be controlled from the publishing side only. The receiving end of the circuit is to be exposed to the test code through an interface, that abstracts as much as possible the receiving end of the test. The interface exposes a set of 'assertions' that may be applied to the receiving end of the test circuit.</p>

<p> In the case where the receiving end of the circuit resides on the same JVM, the assertions will call the receivers code locally. Where the receiving end is distributed accross one or more machines, the assertions will be applied to a test report gethered from all of the receivers. Test code will be written to the assertions making as few assumptions as possible about the exact test topology.</p>

<p> A test circuit defines a test topology, M producers, N consumers, Z outgoing routes between them.<br/>
 The publishing end of each test circuit always resides on a single JVM, even if M &gt; 1. If publishers are to be distributed accross many machines, the test framework itself provides the scaling by running the same test circuit many times in parallel. This means that it is possible to have an arbitrary number of message publishers accross one or many machines, determined by the test setup.<br/>
 The receiving half of the circuit may be local, in which case all messages come back to the same machine, or distributed in which case they may be received by many machines.<br/>
 There are therefore two ways in which tests may be distributed accross multiple nodes in a network; many test circuits may be distributed and run in parallel and/or the receiving ends of those circuits may be distributed or local.<br/>
 Each node in the network can play up to 2 roles in any given test; publisher or receiver. It is possible to play both roles at once, but would like to have a 'single_role' flag, that can be set to ensure that test nodes taking one role, will not participate in the other for the duration of a test. For example, in the pub/sub test want one publisher and the remaining nodes to distribute the receiver role amongst themselves.</p>

<h2><a name="InteropTestingSpecification-Probingfortheavailabletesttopology."></a>Probing for the available test topology.</h2>

<ul>
	<li>Diagram: The available topology.</li>
</ul>


<p> When the test distribution framework starts up, it should broadcast an 'enlist' request on a known topic. All available nodes in the network to reply in order to make it known that they are available to carry out tests. For the requested test case, C test circuits are to be run in parallel. Each test defines its desired M by N topology for each circuit. The entire network may be available to run both roles, or the test case may have specified a limit on the number of publishing nodes and set the 'single_role' flag. If the number of publishing nodes exhausts the available network and the single role flag is on, then there are no nodes available to run the receiver roles, the test will fail with an error at this point. Suppose there are P nodes available to run the publisher roles, and R nodes available to run the receiver roles. The C test circuits will be divided up as evenly as possible amongst the P nodes. The C * N receivers will be divided up as evenly as possible amongst the R nodes.</p>

<p> A more concrete example. There are 10 test machines available. Want to run a pub/sub test with 2 publishers, publishing to 50 topics, with 250 subscribers, measuring total throughput. The distribution framework probes to find the ten machines. The test parameters specify a concurrency level of 2 circuits, limited to 2 nodes, with the single role flag set, which leaves 8 nodes to play the receiver role. The test parameters specify each circuit as having 25 topics, unique to the circuit, and 125 receivers. The total of 250 receivers are distributed amongst the 8 available nodes, 31 each, except for two of them which get 32. The test specifies a duration of 10 minutes, sending messages 500 bytes in size using test batches of 10000 messages, as fast as possible. The distribution framework sends a start signal to each of the publishers. The publishers run for 10000 messages. The publishers request a report from each receiver on their cicruit. The receivers send back to the publishers a report on the number of messages received in the batch. The publishers assert that the correct number for the batch were indeed received, and log a time sample for the batch. This continues for 10 minutes. At the end of the 10 minutes, the publishers collate all of their timings, failures, errors into a log message. The distribution framework requests the test report from each publishing nodes, and these logs are combined together to produce a single log for the entire run. Some stats, such as total time taken, total messages through the system, total throughput are calculated and added as a summary to the log, along with a record of the requested and actual topology used to run the test.</p>

<ul>
	<li>Diagram: The requested test applied onto the available topology.</li>
</ul>


<h2><a name="InteropTestingSpecification-TestProcedures."></a>Test Procedures.</h2>

<p>A variety of different tests can be written against a standard test circuit, many of these will follow a common pattern. One of the aims of using a common test circuit configured by a number of test parameters, is to be able to automate the generation of all possible test cases that can be produced from the circuit combined with the common testing pattern, and an outline of a procedure for doing this is described here. The typical test sequence is described below:</p>

<h3><a name="InteropTestingSpecification-Atypicaltestsequence."></a>A typical test sequence.</h3>

<ol>
	<li>Initialize the test circuit from the default parameters, plus specific settings for the test.</li>
	<li>Create the test circuit. The requested test parameters are applied to the available topology to produce a live circuit.</li>
	<li>Send messages.</li>
	<li>Request a status report.</li>
	<li>Assert conditions on the publishing end of the circuit.</li>
	<li>Assert conditions on the receiving end of the circuit.</li>
	<li>Pass or fail the test.</li>
</ol>


<h3><a name="InteropTestingSpecification-Thethoroughtestprocedure."></a>The thorough test procedure.</h3>

<p>The thorough test procedure uses the typical test sequence described above, but generates all of combinations of test parameters and corresponding assertions against the results.</p>

<p>The all_combinations function produces all combinations of test parameters described in Appendix A.</p>

<p>all_combinations : List&lt;Properties&gt;</p>

<p>The expected_results function, produces a list of assertions, given a set of test parameters. For example, mandatory &amp;&amp; no_route -&gt; assertions.add(producer.assertMessageReturned), assertions.add(receiver.assertMessageNotReceived).</p>

<p>expected_results: Properties -&gt; List&lt;Assertions&gt;</p>

<p>For parameters : all_combinations<br/>
 test_circuit = new TestCircuit(parameters).<br/>
 test_circuit.start.</p>

<p> Send mesages.<br/>
 Request status.</p>

<p> For assertion : exected_results(parameters)<br/>
  Assert(assertion).</p>

<h3><a name="InteropTestingSpecification-CommonRequirements."></a>Common Requirements.</h3>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-3. </th>
<th class='confluenceTh'> Directory Structure. </th>
<td class='confluenceTd'> All scripts to start and stop brokers and run test clients will be placed in a directory structure underneath a top-level directory called 'interop' that sits at the top level of the Qpid project. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-4. </th>
<th class='confluenceTh'> Test Output Format. </th>
<td class='confluenceTd'> Output in junit xml format (because a lot of automated build software understands this format). There doesn't seem to be a schema or DTD for this format but it is simple enough. See Appendix B for an example. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-5. </th>
<th class='confluenceTh'> Terminate On Timeout. </th>
<td class='confluenceTd'> Each client will keep a timeout count. Every time it gets a message it will reset this count. If it does not hear from the broker at all for 60 seconds then it will assume that the broker has died or that the other test clients are failing to communicate with it, and will terminate. Test clients will only wait on this timeout when they are actually expecting messages, for example after enlisting to a test and expecting a role assignment message, or during a test when they are expecting to be sent a test message. If neccessary, this timeout can be extended to a longer time period than 60 secods, its purpose is to ensure eventual termination of all clients during a fully automated build. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-6. </th>
<th class='confluenceTh'> Default Virtual Host. </th>
<td class='confluenceTd'> All test clients will use the default virtual host (no name) for all tests, unless overriden by test parameters for a particular test case, or by command line options when starting the client. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-7. </th>
<th class='confluenceTh'> Broadcast Control Topic. </th>
<td class='confluenceTd'> All test clients will listen to control messages broadcast on the routing key 'iop.control' on the default virtual host on the default topic exchange. This control topic is used for communicating with the test coordinator client. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-48. </th>
<th class='confluenceTh'> Control Message Replies. </th>
<td class='confluenceTd'> All control messages broadcast by the coordinator will include a reply to field. The coordinator will listen on the reply address for responses to its control messages. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-8. </th>
<th class='confluenceTh'> No Environment for Scripts. </th>
<td class='confluenceTd'> In general, start up scripts should be intelligent enough to configure the environment variables that they need in order to run. It should be sufficient to have a path configured for the neccessary run time tools (such as Java) when calling scripts. Environment variables, such as QPID_HOME, should be set by startup scripts themselves, figured out from their installation locations. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-9. </th>
<th class='confluenceTh'> Wait Until Background Process Started. </th>
<td class='confluenceTd'> Scripts that start processes running in the background should not terminate until the process they are starting has succesfully started. This is neccessary for reliable testing, to ensure that subsequent scripts can be run, knowing that previous scripts have completed, with dependant proccesses in a known state. For example, it is important to start all test clients prior to starting the coordinator. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-UseCase1.StartingaBroker."></a>Use Case 1. Starting a Broker.</h3>

<p>  Run the broker start script.<br/>
  The script starts a broker running and tries to connect to it (or otherwise ping it) until it is verified to be running.<br/>
  Once the broker is verified to be running the script terminates with no error code.</p>

<p>  <b>Failure path:</b> The broker fails to start or does not appear to be running after a timeout has passed. The script fails with an error code.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-10. </th>
<th class='confluenceTh'> Broker Start Script. </th>
<td class='confluenceTd'> The Java and C++ brokers will define scripts that can start the broker running on the local machine, and these scripts will be located at interop/java/broker/start and interop/cpp/broker/start. The Java and C++ build processes will generate these scripts (or copy pre-defined ones to the output location) as part of their build processes. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-11. </th>
<th class='confluenceTh'> Broker Start Failure. </th>
<td class='confluenceTd'> If a broker fails to start within 60 seconds its start script will timeout. Script will terminate with error code 1. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-12. </th>
<th class='confluenceTh'> Broker Start Succesfull. </th>
<td class='confluenceTd'> When the broker starts succesfully the script will terminate with error code 0. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-UseCase2.StoppingaBroker."></a>Use Case 2. Stopping a Broker.</h3>

<p>  Run the broker stop script.<br/>
  The script terminates the broker that was started with the start script if it is still running.</p>

<p>  <b>Failure path:</b> The broker won't terminate. The script fails with an error code.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-13. </th>
<th class='confluenceTh'> Broker Stop Script. </th>
<td class='confluenceTd'> The Java and C++ brokers will define scripts that can stop the broker running on the local machine, and these scripts will be located at interop/java/broker/stop and interop/cpp/broker/stop. The Java and C++ build processes will generate these scripts (or copy pre-defined ones to the output location) as part of their build processes. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-14. </th>
<th class='confluenceTh'> Broker Stop Timeout. </th>
<td class='confluenceTd'> If a broker fails to terminate within 60 seconds its stop script will timeout. Script will terminate with error code 1. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-15. </th>
<th class='confluenceTh'> Broker Stop Succesfull. </th>
<td class='confluenceTd'> When the broker stops succesfully the script will terminate with error code 0. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-UseCase3.StartingaTestClient."></a>Use Case 3. Starting a Test Client.</h3>

<p>  Run the client start script. The caller will pass in the address of the broker to connect to.<br/>
  The script starts a client running.<br/>
  The client starts running but waits for further instruction before running its tests.<br/>
  The start script will terminate but leave the client running as a forked process.</p>

<p>  <b>Failure path:</b> The client will not start, or fails to connect to the specified broker. The script will terminate with error code 1.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-16. </th>
<th class='confluenceTh'> Client Start Scripts. </th>
<td class='confluenceTd'> For each client implementation, &lt;client&gt;, there will be a start script located at interop/&lt;client&gt;/client/start. The build processes for each client will generate these scripts and output them to this location as part of their build process. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-17. </th>
<th class='confluenceTh'> Client Start Timeout. </th>
<td class='confluenceTd'> If the client fails to start and connect to the specified broker within 60 seconds the script will terminate with error code 1. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-18. </th>
<th class='confluenceTh'> Client Start Succesfull. </th>
<td class='confluenceTd'> When the client starts successfully its script will terminate with error code 0. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-19. </th>
<th class='confluenceTh'> Client Start Broker and Port. </th>
<td class='confluenceTd'> The -b &lt;hostname&gt; option will be used to instruct the start script to connect to the specified hostname. The -p &lt;port&gt; option will similarly allow the port to be specified. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-20. </th>
<th class='confluenceTh'> Client Virtual Host. </th>
<td class='confluenceTd'> The default virtual host to connect to, may be overridden with the -v &lt;virtual_host&gt; command line option, which will be accepted by all test clients. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-21. </th>
<th class='confluenceTh'> Client Start General Parameters. </th>
<td class='confluenceTd'> General parameters may be passed to the client start scripts using the synax name=value. These name/value pairs may be used by specific test cases to override default test parameters. See Appendix C for a list of test parameters. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-UseCase4.StartingtheCoordinator."></a>Use Case 4. Starting the Coordinator.</h3>

<ul>
	<li>The requirements defined for Use Case 3, also apply to this use case.</li>
</ul>


<p> Run the testall start script. The caller will pass in the address of the broker to connect to.<br/>
 The script starts the coordinator client running.<br/>
 The coordinator will manage the test procedure.<br/>
 The scipt will terminate when the coordinator has completed.</p>

<p> <b>Failure path:</b> The coordinator will not start, or fails to connect to the broker. The script will terminate with error code 1.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-22. </th>
<th class='confluenceTh'> Coordinator Test Script. </th>
<td class='confluenceTd'> There will be a coordinator test script that kicks off the testing process once all clients have been started. It is to be located at interop/testall. It will start a coordinator test client that issues test invites, assigns roles, collects results and terminates test clients when all tests have been run. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-UseCase5.OverallTestProcedure."></a>Use Case 5. Overall Test Procedure.</h3>

<p>  Start a broker running using its start script as described by Use Case 1.<br/>
  Call the start all clients script on each of the machines where there are clients that are to be tested. The caller will pass in address of the broker to connect to, and any additional parameters.<br/>
  The start all script will scan for all start scripts located under interop/&lt;client&gt;/client/start and call each of them forwarding its command line arguments on the call. This performs Use Case 3 for each client.<br/>
  Call the coordinator test client script. This is described as Use Case 4.</p>

<p>  The coordinator test script will broadcast an invite message, with no test name on the control topic. The lack of a test name indicates that this is a compulsory invite, to which all clients must enlist.<br/>
  Each client will respond with an enlist message. This message will contain the routing key on the default topic exchange to which the client has bound its private control queue.<br/>
  The coordinator retains the list of available clients, and the addresses of their control queues.</p>

<p>  The coordinator will broadcast an invite to a named test. This invite may also contain any parameters needed to configure the test, that are relevant to a clients choice to accept the invite or not.<br/>
  All clients that are able to participate in this test will reply to the invite with enlist messages. Clients may opt to participate in the test depending on the test parameters, if desired.<br/>
  The coordinator will send messages to assign roles to the sender and receivers private control topics. These messages will contain the test parameters and roles. The test parameters may also include additional parameters not in the original invite, for test parameters that are to be set on a per test instance basis.<br/>
  The clients will respond with accept role messages.<br/>
  The coordinator will wait until it has received acceptances from both roles.<br/>
  The coordinator will issue a start message to the client with the sender role.<br/>
  The sender client will send its test messages. Once the test has completed the sender will send a report message to the coordinator, giving details about the message that it sent.<br/>
  The coordinator will wait until it receives a report message from the sender.<br/>
  The coordinator will issue a status request message to the reciever role.<br/>
  The receiver will reply with a report, giving details about the messages it has received.<br/>
  The coordinator will wait until it receives a report message from the receiver.<br/>
  The coordinator will compare the sender and receiver reports in order to decide whether the test passed or failed.<br/>
  The coordinator will check its list of available clients and log out failures for any combinations of clients that were not tested because they did not enlist for the test.</p>

<p>  Once all test cases are complete, the coordinator will broadcast a shutdown message.<br/>
  All clients will terminate on receipt of the shutdown message.<br/>
  The coordinator will terminate.<br/>
  Terminate the broker using its stop script.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-23. </th>
<th class='confluenceTh'> Start All Script. </th>
<td class='confluenceTd'> There will be a start all clients script, located at interop/startall. The startall script finds all client starts scripts under interop/&lt;client&gt;/client/start and calls them. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-24. </th>
<th class='confluenceTh'> Start All Script Options Forwarding. </th>
<td class='confluenceTd'> The start all script will take the same command line options as the client start scripts and will pass these command line options on to them. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-25. </th>
<th class='confluenceTh'> Invite Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> For every test case the coordinator will broadcast an invite message on the control topic. This message will be identified by the header field, "CONTROL_TYPE", having the value, "INVITE". This message will also include the name of the test case and may also include some test parameters. (See IOP-48, for the reply to address.)</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "INVITE"
          "TEST_NAME",                  "&lt;test_case&gt;"
          ... optional test parameters.
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-26. </th>
<th class='confluenceTh'> Initial Invite. </th>
<td class='confluenceTd'> At the start of the test procedure the coordinator will broadcast a compulsory invite, to which all available clients must enlist, in order to declare their availability and to enable the coordinator to detect when there are clients that did not participate in some tests. The compulsory invite will be differentiated form an ordinatory invite because it will have no "TEST_NAME" header field. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-27. </th>
<th class='confluenceTh'> Enlist Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Every test client that receives an invite message will respond by declaring its availability to run interop tests. The client will send an enlist message by replying to the invite message. The enlist message will be identified by the header field, "CONTROL_TYPE", having the value, "ENLIST". The client will declare the routing key on which it expects to be sent private control messages. The client will also declare a unique name by which it can be identified (see IOP-35). The declare available message will contain the following header fields with this information: </p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "ENLIST"
          "CLIENT_NAME",                "&lt;client_name&gt;"             (see IOP-35 for rules about the client name).
          "CLIENT_PRIVATE_CONTROL_KEY", "iop.control.&lt;client_name&gt;" (see IOP-36)
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-28. </th>
<th class='confluenceTh'> Assign Role Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Having selected clients to participate in a particular test case, the coordinator will send those clients messages to assign the roles they will play in the test case, on the clients private control topics. Each test case has sender and receiver roles. This message will be identified by the header field, "CONTROL_TYPE", having the value, "ASSIGN_ROLE". The full test parameters will be included in this message, allowing tests to be configured on a per test instance basis.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "ASSIGN_ROLE"
          ... full test parameters.
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-29. </th>
<th class='confluenceTh'> Accept Role Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> A client receiving an assign role message, will reply to it with an accept role message. This message also indicates that the client is ready to start the test. This message will be identifier by the header field, "CONTROL_TYPE", having the value, "ACCEPT_ROLE".</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "ACCEPT_ROLE"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-30. </th>
<th class='confluenceTh'> Start Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> The coordinator will send a start message to begin the test procedure. All test clients will listen for this message on their private control topics. The start message will be identified by the header field, "CONTROL_TYPE", having the value, "START". </p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "START"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-31. </th>
<th class='confluenceTh'> Report Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Once the test clients have completed a test case, they will send the coordinator a report about the actions they have performed. In the case of senders, this report will be sent once they have finished sending test messages. In the case of receiver, this report will be sent in response to a status request from the coordinator (see IOP-49). The report message will be identified by the header field, "CONTROL_TYPE", having the value, "REPORT". Its message body, or additional header fields will contain the report, specific to the test case being run.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "REPORT"
          ... test specific parameters.
          Message body,                 Test case specific report.
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-49. </th>
<th class='confluenceTh'> Status Request Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Once the coordinator has received the senders report, it will send a status request to the receiver, to request the receivers report. This message will be identified by the header field, "CONTROL_TYPE", having the value, "STATUS_REQUEST".</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "STATUS_REQUEST"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-34. </th>
<th class='confluenceTh'> Terminate Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> The coordinator will wait for all test clients to complete their tests for all test cases at which time it will broadcast a terminate message to the control topic. The terminate message will be identified by the header field, "CONTROL_TOPIC", having the value, "TERMINATE". Upon receipt of this message the test clients will terminate.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "TERMINATE"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-35. </th>
<th class='confluenceTh'> Client Name. </th>
<td class='confluenceTd'> Each test client will provide a unique name for itself that reflects its implementation language and distinguishes it from the other clients. Clients may append an environment identifier onto this name to cater for the case where the same client is used multiple times in an interop test. For example, the same client might be run on two different operating systems, in order to check that it works correctly on both. Example names in this case might be "java-win" and "java-linux". </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-36. </th>
<th class='confluenceTh'> Private Client Control Topic. </th>
<td class='confluenceTd'> Each test client will listen for test control messages directed specifically to it on the default topic exchange. The routing key for these messages will consist of "iop.control." followed by the client name (see IOP-35). A topic exchange is used, rather than a direct exchange, to cater for the situation where multiple instances of a client are run in parallel and tests are to be scaled accross many clients (not currently in scope, see Waiting Room). It also allows a listener to be attached to the default topic exchange to listen to all control messages using a wildcard selector. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-37. </th>
<th class='confluenceTh'> Seperate Connection for Control Topic. </th>
<td class='confluenceTd'> Test clients should create open a seperate connection to communicate with the control topics on the default topic exchange, to that which they use to perform tests. This is so that a channel level error that results in the closing of a connection during a test, may still allow a client to succesfully send a failure report to the coordinator. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-CommonRequirementsforTestCases."></a>Common Requirements for Test Cases.</h3>

<p> Test cases that use these requirements mention them in the description of the test case.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-38. </th>
<th class='confluenceTh'> Message Counts. </th>
<td class='confluenceTd'> Whenever a test client recieves a message from another test client it will increment the total count of messages received from that client. Test messages will contain the name of the sending client in the header field "CLIENT_NAME", and the count will be held against a combination of that name and the messages correlation id (see IOP-42). </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-39. </th>
<th class='confluenceTh'> Message Count Reset. </th>
<td class='confluenceTd'> Whenever a test client is begining a new test case (when it accepts a role) it will reset its message counts to zero. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-41. </th>
<th class='confluenceTh'> Message Count Report Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Upon receipt of a status request message, a test client will reply with a report message. The report message will be identified by the header field "CONTROL_TYPE", having the value, "REPORT" (as described by IOP-31). In addition to this, the header field, "MESSAGE_COUNT" will contain the count of messages received since the last reset as a signed 32-bit integer.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "REPORT"
          "MESSAGE_COUNT",              &lt;count&gt;         (signed 32 bit integer)
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-42. </th>
<th class='confluenceTh'> Correlation Id. </th>
<td class='confluenceTd'> When sending test messages, clients will identify all messages using a unique correlation id for the test case instance. This will differentiate test messages in a situation where the same client is scaled up to run a test case many times in parallel (not in scope, see Waiting Room). </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-43. </th>
<th class='confluenceTh'> Test Connections. </th>
<td class='confluenceTd'> Test clients will create connections to send test messages on when they are assigned roles. In many cases this will consist of creating a single connection, and a producer or consumer for the test routing key or queue. In some tests, which simulate the activity of many message receivers, multiple connections may be opened. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-TestCase1.DummyRun."></a>Test Case 1. Dummy Run.</h3>

<p> The sending client will not send any test messages at all. It will send a report message on the control topic, declaring that the test has passed.</p>

<p> The purpose of this test case is to check that clients can interoperate succesfully with the test coordinator and participate in the sequencing of the tests.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-50. </th>
<th class='confluenceTh'> Test Case 1 Name. </th>
<td class='confluenceTd'> The "TEST_NAME" field in the test invite (IOP-25) will be "TC1_DummyRun" for this test. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-TestCase2.BasicP2PTest."></a>Test Case 2. Basic P2P Test.</h3>

<ul>
	<li>This test case uses requirements IOP-38 to 43 inclusive.</li>
</ul>


<p> The sending client creates a fresh correlation id, and the entire test case conversation uses this id.<br/>
 The sending client will send the required number of test messages to the test routing key on the default direct exchange.<br/>
 The sending client will send a message count report to the coordinator.<br/>
 In response to a status request from the coordinator, the receiving client will reply with a message count report.<br/>
 The coordinator will compare the messages received to the messages sent and pass or fail the test accordingly.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-44. </th>
<th class='confluenceTh'> Basic P2P Setup. </th>
<td class='confluenceTd'> Prior to assigning roles, the coordinator will bind a queue to the default direct exchange with a routing key, the same as the queue name. It will create a fresh queue and key for every test case instance. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-45. </th>
<th class='confluenceTh'> Basic P2P Assign Role Parameters. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> In addition to the invite message format defined in IOP-26, the basic p2p test invite will also include the following parameters.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "P2P_QUEUE_AND_KEY_NAME",     "&lt;name&gt;"
          "P2P_NUM_MESSAGES",           &lt;count&gt;  (signed 32 bit int), P2P_NUM_MESSAGES property.
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-51. </th>
<th class='confluenceTh'> Test Case 2 Name. </th>
<td class='confluenceTd'> The "TEST_NAME" field in the test invite (IOP-25) will be "TC2_BasicP2P" for this test. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-TestCase3.BasicPub%2FSubTest."></a>Test Case 3. Basic Pub/Sub Test.</h3>

<ul>
	<li>This test case uses requirements IOP-38 to 43 inclusive.</li>
</ul>


<p> The sending client creates a fresh correlation id, and the entire test case conversation uses this id.<br/>
 The sending client will send the required number of test messages to the test routing key on the default topic exchange.<br/>
 The sending client will send a message count report to the coordinator.<br/>
 In response to a status request from the coordinator, the receiving client will reply with a message count report. This number will be the number of messages sent multiplied by the number of receivers being simulated by the receiving client.<br/>
 The coordinator will compare the messages received to the messages sent and pass or fail the test accordingly.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-46. </th>
<th class='confluenceTh'> Basic Pub/Sub Setup. </th>
<td class='confluenceTd'> Prior to assigning roles, the coordinator will choose a routing key for the test. If will create a fresh key for every test case instance. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-47. </th>
<th class='confluenceTh'> Basic Pub/Sub Invite Parameters. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> In addition to the invite message format defined in IOP-26, the basic pub/sub test invite will also include the following parameters.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "PUBSUB_KEY",                  "&lt;key&gt;"
          "PUBSUB_NUM_RECEIVERS",        &lt;count&gt; (signed 32 bit int), PUBSUB_NUM_RECEIVERS property.
          "PUBSUB_NUM_MESSAGES",         &lt;count&gt; (signed 32 bit int), PUBSUB_NUM_MESSAGES property.
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-52. </th>
<th class='confluenceTh'> Test Case 3 Name. </th>
<td class='confluenceTd'> The "TEST_NAME" field in the test invite (IOP-25) will be "TC3_BasicPubSub" for this test. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-TestCase4.P2PTestwithDifferentMessageSizes."></a>Test Case 4. P2P Test with Different Message Sizes.</h3>

<ul>
	<li>This test case uses requirements IOP-38 to 43 inclusive.</li>
</ul>


<p> The sending client creates a fresh correlation id, and the entire test case conversation uses this id.<br/>
 The sending client will send the required number of test messages to the test routing key on the default direct exchange.<br/>
 The sending client will send a message count report to the coordinator.<br/>
 In response to a status request from the coordinator, the receiving client will reply with a message count report.<br/>
 The coordinator will compare the messages received to the messages sent and pass or fail the test accordingly.<br/>
 The above test cycle will be repeated for each message size to test.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-53. </th>
<th class='confluenceTh'> P2P Message Size Test Setup. </th>
<td class='confluenceTd'> Prior to assigning roles, the coordinator will bind a queue to the default direct exchange with a routing key, the same as the queue name. It will create a fresh queue and key for every test case instance. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-54. </th>
<th class='confluenceTh'> P2P Message Size Test Assign Role Parameters. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> In addition to the invite message format defined in IOP-26, the basic p2p test invite will also include the following parameters.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "P2P_QUEUE_AND_KEY_NAME",     "&lt;name&gt;"
          "P2P_NUM_MESSAGES",           &lt;count&gt;  (signed 32 bit int), P2P_NUM_MESSAGES property.
          "messageSize",                &lt;count&gt;  (signed 32-bit int).
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-55. </th>
<th class='confluenceTh'> P2P Message Size Test Sizes </th>
<td class='confluenceTd'> The following values for the message size parameter will be tested: 0K, 63K, 64K, 65K, 127K, 128K, 129K, 255K, 256K, 257K. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-56. </th>
<th class='confluenceTh'> Test Case 4 Name. </th>
<td class='confluenceTd'> The "TEST_NAME" field in the test invite (IOP-25) will be "TC4_P2PMessageSize" for this test. </td>
</tr>
</tbody></table>

<h3><a name="InteropTestingSpecification-TestCase5.Pub%2FSubTestwithDifferentMessageSizes."></a>Test Case 5. Pub/Sub Test with Different Message Sizes.</h3>

<ul>
	<li>This test case uses requirements IOP-38 to 43 inclusive.</li>
</ul>


<p> The sending client creates a fresh correlation id, and the entire test case conversation uses this id.<br/>
 The sending client will send the required number of test messages to the test routing key on the default topic exchange.<br/>
 The sending client will send a message count report to the coordinator.<br/>
 In response to a status request from the coordinator, the receiving client will reply with a message count report. This number will be the number of messages sent multiplied by the number of receivers being simulated by the receiving client.<br/>
 The coordinator will compare the messages received to the messages sent and pass or fail the test accordingly.<br/>
 The above test cycle will be repeated for each message size to test.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP-57. </th>
<th class='confluenceTh'> Pub/Sub Message Size Test Setup. </th>
<td class='confluenceTd'> Prior to assigning roles, the coordinator will choose a routing key for the test. If will create a fresh key for every test case instance. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-58. </th>
<th class='confluenceTh'> Pub/Sub Message Size Test Invite Parameters. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> In addition to the invite message format defined in IOP-26, the basic pub/sub test invite will also include the following parameters.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "PUBSUB_KEY",                 "&lt;key&gt;"
          "PUBSUB_NUM_RECEIVERS",       &lt;count&gt; (signed 32 bit int), PUBSUB_NUM_RECEIVERS property.
          "PUBSUB_NUM_MESSAGES",        &lt;count&gt; (signed 32 bit int), PUBSUB_NUM_MESSAGES property.
          "messageSize",                &lt;count&gt; (signed 32-bit int).
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-59. </th>
<th class='confluenceTh'> P2P Message Size Test Sizes </th>
<td class='confluenceTd'> The following values for the message size parameter will be tested: 0K, 63K, 64K, 65K, 127K, 128K, 129K, 255K, 256K, 257K. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP-60. </th>
<th class='confluenceTh'> Test Case 5 Name. </th>
<td class='confluenceTd'> The "TEST_NAME" field in the test invite (IOP-25) will be "TC5_PubSubMessageSize" for this test. </td>
</tr>
</tbody></table>

<h2><a name="InteropTestingSpecification-WaitingRoom%3A"></a>Waiting Room:</h2>

<p> Contains ideas for possible future directions relating to this spec.</p>

<p> <ins>Command processor.</ins> Test cases to be written using a command language (perhaps in XML) on top of a common client API. Interpreter for this to be implemented using each client library. Test cases need only be written once and can be run by the interpreters. Command language rich enough to exercise the whole AMQP protocol. May not handle client specific edge cases. Good for ensuring test consistency, but may take a fair amount of time to do.</p>

<p> <ins>How I anticipate this being run as part of a fully automated build.</ins> Will try to get a free licence for Anthill Pro 3 as they offer free licences for open source projects. Viewtier Parabuild is another possibility. Anthill Pro runs a central build server that does all its work through build agents that can run on many boxes. It also lets you define build workflows. I imagine running a Unix agent to build the c++, java and python stuff, and a Windows agent for the .net stuff. Will define a workflow that starts a broker on the unix box, then starts all clients built on the unix and windows boxes in parallel, then runs the entire test procedure across all clients, then terminates the broker on the unix box. The agents send back the test results to the central server.</p>

<p> <ins>Full testing of field tables.</ins> Make sure that every possible data type is tested and confirmed to encode and decode correctly between all client implementations.</p>

<p> <ins>Testing more of the protocol.</ins> Add tests to more fully exercise the complete AMQP protocol.</p>

<p> <ins>Allow scaling of test clients.</ins> Each test client should only be run once (in each environment) and they create unique names for themselves. Tests are only run between pairs of single clients, with a single sender and number of receivers defined by the test case (often 1). Clients listen for control messages on topics, and use correlation id's in all tests messages to differentiate themselves, were multiple senders to be active. This has been done deliberately to allow for future expansion of the test framework to allow scaling up of the tests by starting more clients in parallel on the same environment. To do this each client might also create a sequence number, to unqiuely identify itself, as the client names will no longer be unique. Reports from senders will include client name, sequence number and correlation id. Status requests to receivers may specify client name, sequence number and correlation id to get specific reports, or ommit correlation id or sequence number to get a bulk report of all messages with a particular client.</p>

<p> <ins>More sophisticated reporting.</ins> Message count reports are fairly minimal. Might also put an entire list of messages send/recieved in a report, in order to check that there were no ommissions or duplicates.</p>

<h2><a name="InteropTestingSpecification-AppendixA%2CGeneralNotes%3A"></a>Appendix A, General Notes:</h2>

<p> Brokers that need to be interop tested: C++ and Java</p>

<p> Clients that need to be interop tested: C++ , Java, Java 1.4 retrotranslation, C++, .Net 2.0, .Net 1.1, (Mono?), Python, Ruby.</p>

<h2><a name="InteropTestingSpecification-AppendixB%2CExampleofXMLFormatforTestOuput%3A"></a>Appendix B, Example of XML Format for Test Ouput:</h2>

<p> I don't think there is a DTD or schema for this but the XML output from JUnit looks like the example below. This is a convenient choice for the output format from these test results even if the code does not actually use JUnit (or cppunit or nunit) iternally, because automated build servers generally understand and are able to produce test reports from it.</p>

<p> Example:</p>

<div class="preformatted"><div class="preformattedContent">
<pre>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;testsuite errors="0" skipped="0" tests="18" time="0.02" failures="0" name="org.apache.qpid.framing.BasicContentHeaderPropertiesTest"&gt;
  &lt;properties&gt;
    &lt;property value="Java(TM) 2 Runtime Environment, Standard Edition" name="java.runtime.name"/&gt;
    ... (there were lots of properties).
  &lt;/properties&gt;
  &lt;testcase time="0.02" name="testRejectedExecution"/&gt;
  ... (there were lots of test cases).
&lt;/testsuite&gt;
</pre>
</div></div>

<h2><a name="InteropTestingSpecification-AppendixC%2CTestParameters."></a>Appendix C, Test Parameters.</h2>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'>&nbsp;</th>
<td class='confluenceTd'> Possible Values </td>
<td class='confluenceTd'> Default Value </td>
</tr>
<tr>
<th class='confluenceTh'> Connection properties. </th>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> broker                 </td>
<td class='confluenceTd'> tcp, vm         </td>
<td class='confluenceTd'> tcp://localhost </td>
</tr>
<tr>
<td class='confluenceTd'> vhost                  </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> &lt;empty&gt;         </td>
</tr>
<tr>
<td class='confluenceTd'> username               </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> guest           </td>
</tr>
<tr>
<td class='confluenceTd'> password               </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> guest           </td>
</tr>
<tr>
<th class='confluenceTh'> Topology properties.   </th>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> max_publishing_node    </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 1               </td>
</tr>
<tr>
<td class='confluenceTd'> single_role            </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> true            </td>
</tr>
<tr>
<th class='confluenceTh'> Circuit properties.    </th>
<td class='confluenceTd'> Total: 2^2 = 4 combinations. </td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> num_publishers         </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 1               </td>
</tr>
<tr>
<td class='confluenceTd'> num_consumers          </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 1               </td>
</tr>
<tr>
<td class='confluenceTd'> num_destinations       </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 1               </td>
</tr>
<tr>
<td class='confluenceTd'> base_out_route_name    </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> ping            </td>
</tr>
<tr>
<td class='confluenceTd'> base_in_route_name     </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> pong            </td>
</tr>
<tr>
<td class='confluenceTd'> bind_out_route         </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> true            </td>
</tr>
<tr>
<td class='confluenceTd'> bind_in_route          </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> consumer_out_active    </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> true            </td>
</tr>
<tr>
<td class='confluenceTd'> consumer_in_active     </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<th class='confluenceTh'> JMS flags and options. </th>
<td class='confluenceTd'> Total: 2 * 2 * 2 * 6 = 48 combinations. </td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> transactional          </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> persistent             </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> no_local               </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> ack_mode               </td>
<td class='confluenceTd'> tx, auto, client, dups_ok, no_ack, pre_ack </td>
<td class='confluenceTd'> auto </td>
</tr>
<tr>
<th class='confluenceTh'> AMQP/Qpid flags and options. </th>
<td class='confluenceTd'> Total: 2^4 = 16 combinations. </td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> exclusive              </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> immediate              </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> mandatory              </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> durable                </td>
<td class='confluenceTd'> true, false     </td>
<td class='confluenceTd'> false           </td>
</tr>
<tr>
<td class='confluenceTd'> prefetch_size          </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> header_fields          </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<th class='confluenceTh'> Standard test parameters. </th>
<td class='confluenceTd'> Total: 3 combinations. </td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> message_size           </td>
<td class='confluenceTd'> no_body, one_body, multi_body </td>
<td class='confluenceTd'> one_body </td>
</tr>
<tr>
<td class='confluenceTd'> num_messages           </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 100             </td>
</tr>
<tr>
<td class='confluenceTd'> outgoing_rate          </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> inbound_rate           </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
<tr>
<td class='confluenceTd'> timeout                </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 30 seconds      </td>
</tr>
<tr>
<td class='confluenceTd'> tx_batch_size          </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'> 100             </td>
</tr>
<tr>
<td class='confluenceTd'> max_pending_data       </td>
<td class='confluenceTd'>&nbsp;</td>
<td class='confluenceTd'>&nbsp;</td>
</tr>
</tbody></table>

<p>Total combinations over all test parameters: 4 * 48 * 16 * 3 = 9216 combinations.</p>

<p>Defaults give an in-VM broker, 1:1 P2P topology, no tx, auto ack, no flags, publisher -&gt; receiver route configured, no return route.</p>

<h2><a name="InteropTestingSpecification-AppendixD%2CCommandlineoptions."></a>Appendix D, Command line options.</h2>

<p> IOP-21 states that general parameters can be passed on the command line using name=value syntax. The coordinator understands the following parameters, and will use them to override the default values for the tests. Individual test cases refer to the command line parameter that they take their test parameters from.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> Parameter           </th>
<th class='confluenceTh'> Default </th>
</tr>
<tr>
<td class='confluenceTd'> P2P_NUM_MESSAGES     </td>
<td class='confluenceTd'> 50       </td>
</tr>
<tr>
<td class='confluenceTd'> PUBSUB_NUM_RECEIVERS </td>
<td class='confluenceTd'> 5        </td>
</tr>
<tr>
<td class='confluenceTd'> PUBSUB_NUM_MESSAGES  </td>
<td class='confluenceTd'> 10       </td>
</tr>
</tbody></table>

<h2><a name="InteropTestingSpecification-AppendixE%2CClockSynchronizationAlgorithm."></a>Appendix E, Clock Synchronization Algorithm.</h2>

<p>On connection/initialization of the framework, synch clocks between all nodes in the available toplogy. For in vm tests, the clock delta and error will automatically be zero. For throughput measurements, the overall test times will be long enough that the error does not need to be particularly small. For latency measurements, want to get accurate clock synchronization. This should not be too hard to achieve over a quiet local network.</p>

<p>After determining the list of clients available to conduct tests against, the Coordinator synchronizes the clocks of each in turn. The synchronization is done against one client at a time, at a fairly low messaging rate over the Qpid broker. If needed, a more accurate mechanism, using something like NTP over UDP could be used. Ensure the clock synchronization is captured by an interface, to allow better solutions to be added at a later date. Here is a simple algorithm to get started with:</p>

<ol>
	<li>Coordinator tells client to synchronize its clock with the coordinators time.</li>
	<li>Client stamps current local time on a "time request" message and sends to Coordinator.</li>
	<li>Upon receipt by Coordinator, Coordinator stamps Coordinator-time and returns.</li>
	<li>Upon receipt by Client, Client subtracts current time from sent time and divides by two to compute latency. It subtracts current time from Coordinator time to determine Client-Coordinator time delta and adds in the half-latency to get the correct clock delta.</li>
	<li>The first result should immediately be used to update the clock since it will get the local clock into at least the right ballpark.</li>
	<li>The Client repeats steps 1 through 3, 25 or more times, pausing a few tens of milliseconds each time.</li>
	<li>The results of the packet receipts are accumulated and sorted in lowest-latency to highest-latency order. The median latency is determined by picking the mid-point sample from this ordered list.</li>
	<li>All samples above approximately 1 standard-deviation from the median are discarded and the remaining samples are averaged using an arithmetic mean.</li>
</ol>


<p>The above algorithm includes broker latency, two network hops each way, plus possible effects of buffering/resends on the TCP protocol. A fairly easy improvement on it might be:</p>

<ol>
	<li>Coordinator tells client to synchronize its clock with the coordinators time, provides a port/address to synchronize against.</li>
	<li>Clients sends UDP packets to the Coordinators address and performs the same procedure as outlined above.</li>
</ol>


<h2><a name="InteropTestingSpecification-AppendixF%2CDeletedRequirements%3A"></a>Appendix F, Deleted Requirements:</h2>

<p> Put deleted requirements here, in case they can be re-used.</p>

<table class='confluenceTable'><tbody>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Client Start Messages Per Test. </th>
<td class='confluenceTd'> The -m &lt;num_messages&gt; option will be used to tell the client how many messages to send per test. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Client Number of Receivers. </th>
<td class='confluenceTd'> For topic testing each client will simulate the behaviour of many clients listening to the same topic. The number of receivers per test client for topic tests will be sepcified by the -r &lt;num_receivers&gt; command line option. </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Client Default P2P Test Direct Key. </th>
<td class='confluenceTd'> Each test client will listen for test messages on the default direct exchange. The routing key for these messages will consist of the client name (see IOP-35) followed by ".direct". </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Client Default Pub/Sub Test Direct Key. </th>
<td class='confluenceTd'> Each test client will listen for test messages on the default topic exchange. The routing key for these messages will consist of the client name (see IOP-35) followed by ".topic". </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Test Done Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Once a test client has completed its role, it will send the coordinator a test done message on the control topic. This message will be identified by the header field, "CONTROL_TYPE", having the value, "TEST_DONE". The client will also post its name in the "CLIENT_NAME" header field.</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "TEST_DONE"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> End Role Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> Once the coordinator receives a report for a test case, it will send end role messages to the private control topics of all clients participating in the test case. This message will be identified by the header field, "CONTROL_TYPE", having the value, "END_ROLE".</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "END_ROLE"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
<tr>
<th class='confluenceTh'> IOP. </th>
<th class='confluenceTh'> Client Status Request Message. </th>
<td class='confluenceTd'> <table class="sectionMacro" border="0" cellpadding="5" cellspacing="0" width="100%"><tbody><tr><p> When a test client has completed sending test messages it may request the count of actual messages receieved from the test client to which it sent the messages. The status request message will be send to the receving test clients individual control topic. This message will be identified by the header field, "CONTROL_TYPE", having the value, "STATUS_REQUEST", and will contain the name of the sending client in the header field "CLIENT_NAME".</p>
<div class="preformatted"><div class="preformattedContent">
<pre>          "CONTROL_TYPE",               "STATUS_REQUEST"
          "CLIENT_NAME",                "&lt;client_name&gt;"
</pre>
</div></div> </tr></tbody></table> </td>
</tr>
</tbody></table>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="border/border_bottom.gif"><img src="border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Apr 22, 2008 02:47</font></td>
		    </tr>
	    </table>
    </body>
</html>