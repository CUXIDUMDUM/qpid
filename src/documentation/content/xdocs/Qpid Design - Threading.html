<html>
    <head>
        <title>Apache Qpid : Qpid Design - Threading</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            Apache Qpid : Qpid Design - Threading
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Oct 19, 2006 by <font color="#0050B2">rgreig</font>.
				    </div>

				    <p>The following diagram shows the threading model used in QPID:</p>

<p><img src="Qpid Design - Threading_attachments/QpidThreadingModel.gif" align="absmiddle" border="0" /></p>

<h3><a name="QpidDesign-Threading-Sessions"></a>Sessions</h3>

<p>A session is the encapsulation of a client connection. A session has independent state associated with it.</p>

<h3><a name="QpidDesign-Threading-EventQueues"></a>Event Queues</h3>

<p>The thread pool cannot simply be a generic pool that takes arbitrary work to process. Doing so would mean that no guarantees could be made for message ordering.</p>

<p>Each session has a single read event queue and it is populated by the single socket IO processor associated with the session. (Several sessions can be bound to a single IO processor; the standard select/poll mechanism is used to check for activity). Only one worker (event processing) thread can be processing the event queue for a given session but the particular thread can change over time. If more events come in while the queue is being processed, they are added to the queue being processed, and the worker thread only processes up to <em>n</em> events for fairness.</p>

<p>Similarly, for write events there is a separate queue that behaves analogously to the read queue.</p>

<p>One of the main benefits of this approach is that it allows enough parallelism while avoiding excessive context switching. The socket I/O processor reads as much data as it can - it does very little apart from polls and reads (side note: this makes it very straightforward to move to AIO if support is available). Message decoding (i.e. going from raw bytes to objects) and routing occurs in a worker thread but the entire dispatch process - including encoding but excluding the socket I/O - occurs on a separate worker thread. This means that on a suitable SMP box the following activities can all take place in parallel:</p>
<ul>
	<li>network reading and writing for a given session</li>
	<li>data decoding and routing</li>
	<li>response encoding</li>
</ul>


<p>A further improvement would be to allow reading and writing in parallel by splitting that into separate IO processor threads, and this is being investigated (along with AIO).</p>

<h3><a name="QpidDesign-Threading-MessageDelivery"></a>Message Delivery</h3>

<p>Messages delivered to an AMQQueue are delivered directly if possible (i.e. a write request is written to the consumers session&nbsp;by the thread processing the publish request). This reduces context switch or the overhead of adding and removing messages to a queue. However if there are no consumers then the message needs to be queued. In this case delivery will be done by&nbsp;a 'message pump' thread and direct delivery has to be stopped until the backlog of messages is processed in order to ensure that the ordering is not violated.</p>

				    					    <br/>
                        <div class="tabletitle">
                            <a name="attachments">Attachments:</a>
                        </div>

                        <div class="greybox" align="left">
                                                            <img src="icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="Qpid Design - Threading_attachments/QpidThreadingModel.gif">QpidThreadingModel.gif</a> (image/gif)
                                <br/>
                                                    </div>
				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="border/border_bottom.gif"><img src="border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Apr 22, 2008 02:47</font></td>
		    </tr>
	    </table>
    </body>
</html>