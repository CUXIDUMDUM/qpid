<html>
    <head>
        <title>Apache Qpid : CppHandlerChains</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            Apache Qpid : CppHandlerChains
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Sep 20, 2007 by <font color="#0050B2">aconway</font>.
				    </div>

				    <p>The C++ broker uses handler chains to break complex processing into individual pieces.</p>

<ul>
	<li>Each session has its own set of FrameHandler chains.</li>
	<li>Frames from the network are delivered to the first handler in the chain.</li>
	<li>Handlers do something with a frame, then pass it to the next handler.</li>
	<li>Handlers may "filter" frames by not passing some frames to the next handler.</li>
</ul>


<h1><a name="CppHandlerChains-Currentstatus%282002%2F9%2F20%29"></a>Current status (2002/9/20)</h1>

<p>Each chain starts with a SessionHandler. It handles L2 (session open, close etc.) and passes other frames to the next handler.</p>

<p>L3/L4 frames are handled by the SemanticHandler.</p>

<p>For clustering, a ClusterHandler is inserted at the start of the chain. It replicates frames to a backup broker so the backup can handle failover. It then passes frames on to the normal session handlers.</p>

<h1><a name="CppHandlerChains-Approachformultiframesegments"></a>Approach for multi-frame segments</h1>

<ul>
	<li>The frame handler chain continues to handle individual frames.</li>
	<li>Each handler uses a FrameSet to accumulate its frames.</li>
	<li>Frame no longer contains a Body, moved to FrameSet
<div class="code"><div class="codeContent">
<pre class="code-java">class FrameSet { <span class="code-comment">// sketch
</span> void add(<span class="code-keyword">const</span> Frame&amp; frame); <span class="code-comment">// True <span class="code-keyword">if</span> 
</span> <span class="code-keyword">const</span> AMQMethodBody* getMethod(); <span class="code-comment">// 0 means not complete.
</span> <span class="code-keyword">const</span> AMQHeaderBody* getHeader();
 <span class="code-keyword">const</span> AMQContentBody* getContent(); 
};</pre>
</div></div>
<p>Note: All the visitor/dispatch classes using AMQFrame need to be reworked. Dispatch will always be based on an AMQMethodBody, not a frame. </p></li>
</ul>


<p>Rationale: </p>

<p>''Frame rather than Segment/FrameSet handlers'': Allows most flexibility to compose or not compose frames into segments &amp; FrameSets. For example a cluster handler needs to replicate frame-by-frame, so we don't want to compose the full segment up front. Since the FrameSet class provides the composition logic, this is specified only once and easy to use in frame handlers.</p>

<p>''No Segment class'': A segment by itself is not very useful. A non-content method is just a FrameSet containing a single method segment. For content bearing methods are a frameset with headers &amp; content. There's little value for a stand alone segment class.</p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="border/border_bottom.gif"><img src="border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Apr 22, 2008 02:47</font></td>
		    </tr>
	    </table>
    </body>
</html>